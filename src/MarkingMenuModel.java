import java.awt.Color;
import java.awt.Graphics;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.geom.Line2D;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Vector;

import javax.swing.JComponent;
import javax.swing.event.MouseInputAdapter;
import javax.swing.event.MouseInputListener;

public class MarkingMenuModel extends JComponent {
	// Liste des outils support�s par notre appli
	private final List<String> TOOLS = Arrays.asList("rectangle", "ellipse", "pen", "line"); // ensemble de nos outils
																								// disponibles.

	private String tool = "pen"; // outil courrant, affecté à pen car on à déjà le pen selectionné lors de
									// l'ouverture du programme.
	private Color color = Color.BLACK; // couleur courrante, affecté à black car la couleur black est sélectionnée lors
										// de l'ouverture du programme
	private String nom_couleur = "black"; // nom de la couleur courrante, utile pour l'affichage de la couleur courrante
											// sur le panel (en haut à gauche)
	private String menu = ""; // Menu courrant (Outils ou Couleurs)
	private Vector<Object> composants = new Vector<Object>(); // Liste de composants du marking menu
	private Vector<Button> liste_composants = new Vector<Button>(); // liste des boutons correspondants aux composants
																	// du marking menu
	private Button last_button_selected; // dernier bouton selectionné pour ne pas avoir rien de sélectionner lorsque
											// l'on ferme le menu.

	private int mouseX = -99999; // position de la souris X, affectée à -99999 pour que la ligne entre le centre
									// du marking menu ne se dessine que quand on commence à bouger la souris.
	private int mouseY = -99999; // position Y de la souric, idem.
	private Point origine; // point d'origine du marking menu

	// constructeur, nécessite une liste de composants.
	public MarkingMenuModel(String tool, Color color, Vector<Object> composants) {
		super();
		this.tool = tool;
		this.color = color;
		this.composants = composants;
		for (int i = 0; i < composants.size(); i++) {
			this.liste_composants.addElement(new Button(composants.get(i).toString(), 0, 0));
		}
	}

	// getters and setters autogenerated

	public Button getLast_button_selected() {
		return last_button_selected;
	}

	public void setLast_button_selected(Button last_button_selected) {
		this.last_button_selected = last_button_selected;
	}

	public String getNom_couleur() {
		return nom_couleur;
	}

	public void setNom_couleur(String nom_couleur) {
		this.nom_couleur = nom_couleur;
	}

	public String getMenu() {
		return menu;
	}

	public void setMenu(String menu) {
		this.menu = menu;
	}

	public void setO(Point o) {
		this.origine = o;
	}

	public Point getO() {
		return origine;
	}

	public String getTool() {
		return tool;
	}

	public void setTool(String tool) {
		this.tool = tool;
	}

	public Color getColor() {
		return color;
	}

	public void setColor(Color color) {
		this.color = color;
	}

	public int getMouseX() {
		return mouseX;
	}

	public void setMouseX(int mouseX) {
		this.mouseX = mouseX;
	}

	public int getMouseY() {
		return mouseY;
	}

	public void setMouseY(int mouseY) {
		this.mouseY = mouseY;
	}

	public Vector<Object> getComposants() {
		return composants;
	}

	// fonction permettant de mettre à null le champ last_button_selected qui est le
	// dernier bouton que nous avons sélectionné dans notre MarkingMenu.
	public void unset_buton_selected() {
		this.last_button_selected = null;
	}

	// fonction permettant de changer l'intégralité des composants et donc des
	// boutons du marking menu en lui passant une nouvelle liste de composants.
	public void setComposants(Vector<Object> composants) {
		this.composants = composants; // changement des composants
		this.liste_composants.clear(); // suppression des anciens boutons
		for (int i = 0; i < composants.size(); i++) { // creation des nouveaux boutons.
			this.liste_composants.addElement(new Button(composants.get(i).toString(), 0, 0));
		}
	}

	// ajoute un composant à notre marking menu
	public void addComponent(Object component) {
		this.getComposants().addElement(component);
	}

	// return true si la string passée en paramètre correspond à un outil prédéfini
	// dans le tableau TOOLS.
	public boolean isATool(String s) {
		return TOOLS.contains(s);
	}

	@Override
	public void paintComponent(Graphics g) {
		g.setColor(Color.BLACK);

		// definission de la position des boutons en fonction de la taille du marking
		// menu.
		// nous avons décidés de choisir l'emplacement de cette façon car nous avons
		// décidés que notre marking menu ne pouvait pas avoir plus de 8 éléments. (vu
		// en cours).
		if (this.composants.size() == 1) {
			this.liste_composants.get(0).setXY(200, 100);

		} else if (this.composants.size() == 2) {
			this.liste_composants.get(0).setXY(200, 100);
			this.liste_composants.get(1).setXY(0, 100);

		} else if (this.composants.size() == 3) {
			this.liste_composants.get(0).setXY(200, 100);
			this.liste_composants.get(1).setXY(100, 200);
			this.liste_composants.get(2).setXY(0, 100);

		} else if (this.composants.size() == 4) {
			this.liste_composants.get(0).setXY(200, 100);
			this.liste_composants.get(1).setXY(100, 200);
			this.liste_composants.get(2).setXY(0, 100);
			this.liste_composants.get(3).setXY(100, 0);

		} else if (this.composants.size() == 5) {
			this.liste_composants.get(0).setXY(100, 0);
			this.liste_composants.get(1).setXY(200, 50);
			this.liste_composants.get(2).setXY(150, 200);
			this.liste_composants.get(3).setXY(50, 200);
			this.liste_composants.get(4).setXY(0, 50);

		} else if (this.composants.size() == 6) {
			this.liste_composants.get(0).setXY(100, 0);
			this.liste_composants.get(1).setXY(200, 50);
			this.liste_composants.get(2).setXY(200, 150);
			this.liste_composants.get(3).setXY(100, 200);
			this.liste_composants.get(4).setXY(0, 150);
			this.liste_composants.get(5).setXY(0, 50);

		} else if (this.composants.size() == 7) {
			this.liste_composants.get(0).setXY(100, 0);
			this.liste_composants.get(1).setXY(200, 50);
			this.liste_composants.get(2).setXY(200, 150);
			this.liste_composants.get(3).setXY(150, 200);
			this.liste_composants.get(4).setXY(50, 200);
			this.liste_composants.get(5).setXY(0, 150);
			this.liste_composants.get(6).setXY(0, 50);

		} else if (this.composants.size() == 8) {
			this.liste_composants.get(0).setXY(50, 0);
			this.liste_composants.get(1).setXY(150, 0);
			this.liste_composants.get(2).setXY(200, 50);
			this.liste_composants.get(3).setXY(200, 150);
			this.liste_composants.get(4).setXY(150, 200);
			this.liste_composants.get(5).setXY(50, 200);
			this.liste_composants.get(6).setXY(0, 150);
			this.liste_composants.get(7).setXY(0, 50);

		}

		for (int i = 0; i < liste_composants.size(); i++) {
			Button composant = this.liste_composants.get(i); // bouton courant
			String composantName = composant.getText(); // texte du couton courant
			Line2D l1 = new Line2D.Float(135, 115, this.getMouseX(), this.getMouseY()); // ligne entre le centre du
																						// marking menu et de notre
																						// curseur

			// Si la ligne définie au dessus intersectionne un des boutons du marking menu
			if (l1.intersects(composant) || composant.equals(this.last_button_selected)) {

				if (composantName.equals("Outils")) { // si le bouton est le bouton Outils
					this.setMenu("Outils");
				} else if (composantName.equals("Couleurs")) { // si il s'agit du bouton Couleurs
					this.setMenu("Couleurs");
				}
				// On change l'outil en meme temps qu'un feedback visuel
				else if (isATool(composantName)) { // si le bouton selectionne est un outil
					setTool(composantName); // on change l'outil courant
				} else { // il s'agit ici forcément d'une couleur.
					setColor(stringToColor(composantName)); // on change la couleur courante
					this.setNom_couleur(composantName); // on change le nom de la couleur courante.
				}

				if (this.stringToColor(composant.getText()) != null) { // lorsque le bouton selectionné est une couleur
					composant.drawStringRect(g, true, this.stringToColor(composant.getText()), Color.WHITE); // on
																												// redessine
																												// le
																												// bouton
																												// sans
																												// la
																												// transparence
																												// (de
																												// base),
																												// avec
																												// sa
																												// pleine
																												// couleur

				} else { // pour tous les autres types de boutons (rouge)
					composant.drawStringRect(g, true, Color.GREEN, Color.WHITE); // on le redessine en vert
				}
				this.last_button_selected = composant; // affectation du dernier bouton selectionné
			} else { // Lorsque le bouton n'est pas selectionné
				if (this.stringToColor(composant.getText()) != null) { // si le bouton est une couleur
					Color base = this.stringToColor(composant.getText()); // on récupère la couleur correspondante au
																			// bouton
					Color pastel = new Color(base.getRed(), base.getGreen(), base.getBlue(), 100); // on y intègre de la
																									// transparence
					composant.drawStringRect(g, true, pastel, Color.WHITE); // on dessine le bouton avec la couleur
																			// pastel
				} else { // si le bouton n'est pas une couleur
					composant.drawStringRect(g, true, Color.RED, Color.WHITE); // on le dessine en rouge.
				}
			}
		}

		g.setColor(Color.RED);
		g.fillOval(135 - 10, 115 - 10, 20, 20); // petit rond rouge au centre du marking menu.
		g.setColor(Color.BLACK);

		if (this.getMouseX() != -99999 && this.getMouseY() != -99999) // si la position de la souris n'est pas au
																		// valeurs de base (-99999, -99999)
			g.drawLine(135, 115, this.getMouseX(), this.getMouseY()); // on dessine une ligne entre le centre du marking
																		// menu et le curseur de la souris.

	}

	/**
	 * Essaie de traduire une string en couleur
	 * 
	 * @param composantName la string
	 * @return color l'objet Color, null si le string n'est associé a aucune couleur
	 */
	private Color stringToColor(String composantName) {
		Color color;
		try {
			Field field = Class.forName("java.awt.Color").getField(composantName);
			color = (Color) field.get(null);
		} catch (Exception e) { // le string ne correspond a aucune couleur, donc exception.
			color = null;
		}
		return color;
	}

}
